"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
var _typeof = require("@babel/runtime/helpers/typeof");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CopyAddressButton = void 0;
exports.stringTruncateFromCenter = stringTruncateFromCenter;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("@chakra-ui/react");
var _react2 = _interopRequireWildcard(require("react"));
var _fa = require("react-icons/fa");
var _fi = require("react-icons/fi");
var _defaultComponent = require("./default-component");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
var SIZES = {
  lg: {
    height: 12,
    walletImageSize: 7,
    icon: 5,
    fontSize: 'md'
  },
  md: {
    height: 10,
    walletImageSize: 6,
    icon: 4,
    fontSize: 'sm'
  },
  sm: {
    height: 7,
    walletImageSize: 5,
    icon: 3.5,
    fontSize: 'sm'
  }
};
function stringTruncateFromCenter(str, maxLength) {
  var midChar = 'â€¦'; // character to insert into the center of the result

  if (str.length <= maxLength) return str;

  // length of beginning part
  var left = Math.ceil(maxLength / 2);

  // start index of ending part
  var right = str.length - Math.floor(maxLength / 2) + 1;
  return str.substring(0, left) + midChar + str.substring(right);
}
var CopyAddressButton = function CopyAddressButton(_ref) {
  var address = _ref.address,
    walletIcon = _ref.walletIcon,
    isLoading = _ref.isLoading,
    isRound = _ref.isRound,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? 'md' : _ref$size,
    maxDisplayLength = _ref.maxDisplayLength;
  var _useClipboard = (0, _react.useClipboard)(address ? address : ''),
    hasCopied = _useClipboard.hasCopied,
    onCopy = _useClipboard.onCopy;
  var _useState = (0, _react2.useState)(''),
    _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
    displayAddress = _useState2[0],
    setDisplayAddress = _useState2[1];
  var _useColorMode = (0, _react.useColorMode)(),
    colorMode = _useColorMode.colorMode;
  var defaultMaxLength = {
    lg: 14,
    md: 16,
    sm: 18
  };
  (0, _react2.useEffect)(function () {
    if (!address) setDisplayAddress('address not identified yet');
    if (address && maxDisplayLength) setDisplayAddress(stringTruncateFromCenter(address, maxDisplayLength));
    if (address && !maxDisplayLength) setDisplayAddress(stringTruncateFromCenter(address, defaultMaxLength[size]));
  }, [address]);
  return /*#__PURE__*/_react2["default"].createElement(_react.Button, {
    title: address,
    variant: "unstyled",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: isRound ? 'full' : 'lg',
    border: "1px solid",
    borderColor: (0, _defaultComponent.handleChangeColorModeValue)(colorMode, 'gray.200', 'whiteAlpha.300'),
    w: "full",
    h: SIZES[size].height,
    minH: "fit-content",
    pl: 2,
    pr: 2,
    color: (0, _defaultComponent.handleChangeColorModeValue)(colorMode, 'gray.700', 'whiteAlpha.600'),
    transition: "all .3s ease-in-out",
    isDisabled: !address && true,
    isLoading: isLoading,
    _hover: {
      bg: 'rgba(142, 142, 142, 0.05)'
    },
    _focus: {
      outline: 'none'
    },
    _disabled: {
      opacity: 0.6,
      cursor: 'not-allowed',
      borderColor: 'rgba(142, 142, 142, 0.1)',
      _hover: {
        bg: 'transparent'
      },
      _active: {
        outline: 'none'
      },
      _focus: {
        outline: 'none'
      }
    },
    onClick: onCopy
  }, address && walletIcon && /*#__PURE__*/_react2["default"].createElement(_react.Box, {
    borderRadius: "full",
    w: "full",
    h: "full",
    minW: SIZES[size].walletImageSize,
    minH: SIZES[size].walletImageSize,
    maxW: SIZES[size].walletImageSize,
    maxH: SIZES[size].walletImageSize,
    mr: 2,
    opacity: 0.85
  }, /*#__PURE__*/_react2["default"].createElement(_react.Image, {
    alt: displayAddress,
    src: walletIcon
  })), /*#__PURE__*/_react2["default"].createElement(_react.Text, {
    fontSize: SIZES[size].fontSize,
    fontWeight: "normal",
    letterSpacing: "0.4px",
    opacity: 0.75
  }, displayAddress), address && /*#__PURE__*/_react2["default"].createElement(_react.Icon, {
    as: hasCopied ? _fa.FaCheckCircle : _fi.FiCopy,
    w: SIZES[size].icon,
    h: SIZES[size].icon,
    ml: 2,
    opacity: 0.9,
    color: hasCopied ? 'green.400' : (0, _defaultComponent.handleChangeColorModeValue)(colorMode, 'gray.500', 'whiteAlpha.400')
  }));
};
exports.CopyAddressButton = CopyAddressButton;