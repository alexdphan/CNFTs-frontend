import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/* eslint-disable no-empty */
/* eslint-disable no-console */

import { StateBase } from './bases/state';
/**
 * Store all ChainWallets for a particular Chain.
 */
export class WalletRepo extends StateBase {
  constructor(chainRecord, wallets = [], sessionOptions) {
    super();
    _defineProperty(this, "isInUse", false);
    _defineProperty(this, "chainRecord", void 0);
    _defineProperty(this, "_wallets", void 0);
    _defineProperty(this, "options", {
      mutexWallet: true // only allow one wallet type to connect one time
    });
    _defineProperty(this, "sessionOptions", void 0);
    _defineProperty(this, "getWallet", walletName => {
      return this.wallets.find(w => w.walletName === walletName);
    });
    _defineProperty(this, "openView", () => {
      this.actions?.viewWalletRepo?.(this);
      this.actions?.viewOpen?.(true);
    });
    _defineProperty(this, "closeView", () => {
      this.actions?.viewOpen?.(false);
    });
    _defineProperty(this, "connect", async walletName => {
      if (walletName) {
        const wallet = this.getWallet(walletName);
        await wallet?.connect(this.sessionOptions);
      } else if (this.isSingleWallet) {
        const wallet = this.wallets[0];
        await wallet?.connect(this.sessionOptions);
      } else {
        this.openView();
      }
    });
    _defineProperty(this, "disconnect", async walletName => {
      if (walletName) {
        await this.getWallet(walletName)?.disconnect();
      } else {
        for (const w of this.wallets) {
          await w.disconnect();
        }
      }
    });
    _defineProperty(this, "getRpcEndpoint", async () => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getRpcEndpoint();
        } catch (error) {}
      }
      throw new Error(`No valid RPC endpoint for chain ${this.chainName}!`);
    });
    _defineProperty(this, "getRestEndpoint", async () => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getRestEndpoint();
        } catch (error) {}
      }
      throw new Error(`No valid REST endpoint for chain ${this.chainName}!`);
    });
    _defineProperty(this, "getStargateClient", async () => {
      for (const wallet of this.wallets) {
        try {
          return await wallet.getStargateClient();
        } catch (error) {}
      }
      throw new Error(`Something wrong! Probably no valid RPC endpoint for chain ${this.chainName}.`);
    });
    _defineProperty(this, "getCosmWasmClient", async () => {
      for (const wallet of this.wallets) {
        const client = await wallet.getCosmWasmClient();
        if (client) {
          return client;
        }
      }
      throw new Error(`Something wrong! Probably no valid RPC endpoint for chain ${this.chainName}.`);
    });
    this.chainRecord = chainRecord;
    this.sessionOptions = sessionOptions;
    this._wallets = wallets;
    if (this.options.mutexWallet) {
      this.wallets.forEach(w => {
        w.updateCallbacks(_objectSpread(_objectSpread({}, w.callbacks), {}, {
          beforeConnect: async () => {
            this.wallets.forEach(async w2 => {
              if (!w2.isWalletDisconnected && w2 !== w) {
                await w2.disconnect();
              }
            });
          }
        }));
      });
    }
  }
  setEnv(env) {
    this._env = env;
    this.wallets.forEach(w => w.setEnv(env));
  }
  get chainName() {
    return this.chainRecord.name;
  }
  get chainLogo() {
    return (
      // until chain_registry fix this
      // this.chainInfo.chain.logo_URIs?.svg ||
      // this.chainInfo.chain.logo_URIs?.png ||
      // this.chainInfo.chain.logo_URIs?.jpeg ||
      this.chainRecord.assetList?.assets[0]?.logo_URIs?.svg || this.chainRecord.assetList?.assets[0]?.logo_URIs?.png || undefined
    );
  }
  get wallets() {
    if (this.isMobile) {
      return this._wallets.filter(wallet => !wallet.walletInfo.mobileDisabled);
    }
    return this._wallets;
  }
  get isSingleWallet() {
    return this.wallets.length === 1;
  }

  // you should never use current when `uniqueWallet` is set false
  get current() {
    if (!this.options.mutexWallet) {
      console.warn("It's meaningless to use current when `uniqueWallet` is set false.");
      return void 0;
    }
    return this.wallets.find(w => !w.isWalletDisconnected);
  }
}