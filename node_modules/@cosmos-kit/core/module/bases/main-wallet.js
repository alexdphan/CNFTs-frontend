import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { State } from '../types';
import { WalletBase } from './wallet';
export class MainWalletBase extends WalletBase {
  constructor(walletInfo, ChainWallet) {
    super(walletInfo);
    _defineProperty(this, "_chainWallets", void 0);
    _defineProperty(this, "preferredEndpoints", void 0);
    _defineProperty(this, "ChainWallet", void 0);
    _defineProperty(this, "getChainWallet", chainName => {
      return this.chainWallets?.get(chainName);
    });
    this.ChainWallet = ChainWallet;
    this.clientPromise = this.fetchClient();
  }
  onSetChainsDone() {
    this.chainWallets?.forEach(chainWallet => {
      chainWallet.client = this.client;
      chainWallet.clientPromise = this.clientPromise;
      chainWallet.fetchClient = this.fetchClient;
    });
  }
  setChains(chains) {
    this._chainWallets = new Map(chains.map(chain => {
      chain.preferredEndpoints = {
        rpc: [...(chain.preferredEndpoints?.rpc || []), ...(this.preferredEndpoints?.[chain.name]?.rpc || []), `https://rpc.cosmos.directory/${chain.name}`, ...(chain.chain?.apis?.rpc?.map(e => e.address) || [])],
        rest: [...(chain.preferredEndpoints?.rest || []), ...(this.preferredEndpoints?.[chain.name]?.rest || []), `https://rest.cosmos.directory/${chain.name}`, ...(chain.chain?.apis?.rest?.map(e => e.address) || [])]
      };
      return [chain.name, new this.ChainWallet(this.walletInfo, chain)];
    }));
    this.onSetChainsDone();
  }
  get username() {
    return this.data?.username;
  }
  get chainWallets() {
    return this._chainWallets;
  }
  async update(sessionOptions, callbacks) {
    await (callbacks || this.callbacks)?.beforeConnect?.();
    if (!this.client) {
      this.setClientNotExist();
      return;
    }
    this.setState(State.Done);
    if (sessionOptions?.duration) {
      setTimeout(() => {
        this.disconnect(callbacks);
      }, sessionOptions?.duration);
    }
    await (callbacks || this.callbacks)?.afterConnect?.();
  }
  reset() {
    this.chainWallets?.forEach(chain => {
      chain.reset();
    });
    this.setData(undefined);
    this.setMessage(undefined);
    this.setState(State.Init);
  }
}