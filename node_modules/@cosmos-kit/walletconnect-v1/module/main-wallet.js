import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
/* eslint-disable no-console */
import { MainWalletBase } from '@cosmos-kit/core';
import EventEmitter from 'events';
export class WCWalletV1 extends MainWalletBase {
  constructor(walletInfo, ChainWC, WCClient) {
    super(walletInfo, ChainWC);
    _defineProperty(this, "client", void 0);
    _defineProperty(this, "emitter", void 0);
    _defineProperty(this, "connect", async (sessionOptions, callbacks) => {
      this.setMessage('About to connect.');
      this.emitter.removeAllListeners();
      this.emitter.on('update', async () => {
        await this.update(sessionOptions, callbacks);
      });
      this.emitter.on('disconnect', async () => {
        await this.disconnect(callbacks);
      });
      if (!this.connector.connected) {
        await this.connector.createSession();
      } else {
        if (!this.isMobile) {
          await this.update(sessionOptions, callbacks);
        }
      }
      if (this.isMobile) {
        await this.update(sessionOptions, callbacks);
        if (window && this.appUrl) {
          window.location.href = this.appUrl;
        }
      }
    });
    _defineProperty(this, "disconnect", async callbacks => {
      await (callbacks || this.callbacks)?.beforeDisconnect?.();
      if (this.connector.connected) {
        await this.connector.killSession();
      }
      this.chainWallets?.forEach(chain => {
        chain.reset();
      });
      this.reset();
      this.emitter.removeAllListeners();
      await this.client?.disconnect?.();
      await (callbacks || this.callbacks)?.afterDisconnect?.();
    });
    this.client = new WCClient();
    this.emitter = new EventEmitter();
    this.connector.on('connect', async error => {
      if (error) {
        throw error;
      }
      this.emitter.emit('update');
    });
    this.connector.on('session_update', async error => {
      if (error) {
        throw error;
      }
      this.emitter.emit('update');
    });
    this.connector.on('disconnect', error => {
      if (error) {
        throw error;
      }
      this.emitter.emit('disconnect');
    });
  }
  get connector() {
    return this.client?.connector;
  }
  get qrUrl() {
    return this.connector.uri;
  }
  get appUrl() {
    return this.client?.getAppUrl(this.env?.os);
  }
  fetchClient() {
    return this.client;
  }
  onSetChainsDone() {
    this.chainWallets?.forEach(chainWallet => {
      chainWallet.client = this.client;
      chainWallet.clientPromise = this.clientPromise;
      chainWallet.emitter = this.emitter;
      // chainWallet.connect = this.connect;
      // chainWallet.disconnect = this.disconnect;
    });
  }
}